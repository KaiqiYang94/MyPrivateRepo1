
const Empty=0
const TaggedBicycle=1
const UntaggedBicycle=2
const TaggedBicycleChecked=3
const UntaggedBicycleChecked=4
const TaggedBicycleInspected=5

range Bicycles = TaggedBicycle..TaggedBicycleInspected
range Segment =Empty..TaggedBicycleInspected
range UncheckedBicycles = TaggedBicycle..UntaggedBicycle
range CheckedBicycles = TaggedBicycleChecked..UntaggedBicycleChecked


PRODUCER = (put[TaggedBicycle] ->PRODUCER |put[UntaggedBicycle] -> PRODUCER).
CONSUMER = (get[n:CheckedBicycles] -> CONSUMER).

//BICYCLES

//BELT

//ROBOT

//SENSOR
SENSOR = (check -> SENSOR).
//SENSOR[n: Segment] = 
//		(when(n == TaggedBicycle) check[TaggedBicycle]->SENSOR[TaggedBicycleChecked]
//		|when(n == UntaggedBicycle) check[UntaggedBicycle]->SENSOR[UntaggedBicycleChecked]
//		|when (n != TaggedBicycle && n!= UntaggedBicycle) check[n]->SENSOR[n]).

//INSPECTOR


// initialized status
BELT=BELT[Empty][Empty][Empty][Empty][Empty],
BELT[n0:Segment][n1:Segment][n2:Segment][n3:Segment][n4:Segment]=(
// the bicycle must be checked after the new status established
when(n2 == TaggedBicycle) check-> BELT[n0][n1][TaggedBicycleChecked][n3][n4]
| when(n2 == UntaggedBicycle) check-> BELT[n0][n1][UntaggedBicycleChecked][n3][n4]


// the rest of the conditions must assert that the 3rd bicycle has been checked
// bicycles can be put the belt
| when((n2 != TaggedBicycle && n2 != UntaggedBicycle) && n0==Empty) put[n5:UncheckedBicycles]-> BELT[n5][n1][n2][n3][n4]

//Bicycles can be get from the belt
| when((n2 != TaggedBicycle && n2 != UntaggedBicycle) && n4!=Empty) get[n4]->BELT[n0][n1][n2][n3][Empty]

// move when (the last segment is empty and the belt is not empty)
| when((n2 != TaggedBicycle && n2 != UntaggedBicycle) && n4==Empty && !(n0 == Empty && n1 == Empty && n2 == Empty && n3 == Empty)) move->BELT[Empty][n0][n1][n2][n3] 
// here should followed by the checking* functions and other stuff waiting on the belt 
).

||SYSTEM=(PRODUCER||BELT||CONSUMER||SENSOR).
